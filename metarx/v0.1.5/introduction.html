<!DOCTYPE html><html lang="en-GB">
        <head>
          <title>MetaRx User Manual v0.1.5 - Introduction</title>
          <meta charset="utf-8"/>
          <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
          <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
          <meta name="generator" content="MetaDocs v0.1.1"/>
          <link rel="shortcut icon" href="favicon.ico"/>
          
          <link rel="stylesheet" type="text/css" href="css/kult.css"/><link rel="stylesheet" type="text/css" href="css/default.min.css"/>
        </head>

        <body>
          <div id="wrapper">
      <header>
            <h1 class="title">MetaRx User Manual v0.1.5</h1>
          </header><nav><a href="index.html">Table of contents</a> | <span>Next chapter: <a href="reactive-programming.html">Reactive programming</a></span> | <span><a href="https://github.com/MetaStack-pl/MetaRx/edit/master/manual/introduction.md">Edit source</a></span></nav><h1 id="introduction">Introduction</h1><p>MetaRx provides reactive data structures for Scala and Scala.js. It is particularly useful in conjunction with user interfaces.</p><h2 id="installation">Installation</h2><p>Add the following dependencies to your build configuration:</p><pre class="sourceCode scala"><code data-lang="scala">libraryDependencies += &quot;pl.metastack&quot; %%  &quot;metarx&quot; % &quot;0.1.5&quot;  // Scala
libraryDependencies += &quot;pl.metastack&quot; %%% &quot;metarx&quot; % &quot;0.1.5&quot;  // Scala.js</code></pre><h2 id="example">Example</h2><p>The following example illustrates how you can model data flows in MetaRx.</p><p>In the first line, we define a <i>channel</i> that takes integer values. We derive from it another channel that increments every value by 1. The <span class="code">===</span> operator in line 3 yields a channel that produces <span class="code">true</span> if the current value is 1, otherwise <span class="code">false</span>.</p><p><span class="code">attach()</span> attaches a callback that is executed for every produced value.</p><p><pre class="sourceCode scala"><code data-lang="scala">import pl.metastack.metarx._

val ch      = Channel[Int]()
val plusOne = ch.map(_ + 1)
val isOne   = plusOne === 1

isOne.attach(println)

ch := 1</code></pre><b>Output:</b><pre class="sourceCode"><code>false</code></pre></p><h2 id="features">Features</h2><ul><li>Reactive data structures:<ul><li>Channels</li><li>Buffers</li><li>Dictionaries</li><li>Sets</li></ul></li><li>Scala.js support</li><li>Thread-safe</li></ul><h2 id="comparison">Comparison</h2><p>MetaRx was developed with simplicity in mind. By design, it doesnâ€™t support back-pressure. It can be used in conjunction with other frameworks such as <a href="http://doc.akka.io/docs/akka-stream-and-http-experimental/current/scala.html">Akka Streams</a>.</p>
      <p><small>Generated with <a href="http://github.com/MetaStack-pl/MetaDocs">MetaDocs v0.1.1</a></small></p>
    </div>
          <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script src="js/main.js"></script><script src="js/highlight.pack.js"></script>
          <script>hljs.initHighlightingOnLoad();</script>
        </body>
      </html>